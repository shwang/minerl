# TODO(shwang): Migration notes -- didn't integration this file into env/core.py's
# MineRLEnv, which uses this to set "observation handlers" on the environment.
#
# Consequently we cannot run any environment that uses these custom feature
# (there is only one environment in realistic_benchmarks that uses obs handler,
# called "Inventory" something).

import os
import functools

dir_path = os.path.dirname(os.path.realpath(__file__))


def get_item_block_lists():
    """
    :return: items: a list of strings, corresponding to minecraft items in a player's inventory.
            blocks: a list of strings, corresponding to minecraft blocks in the world.

        Where do items.txt and blocks.txt come from? Better for your sanity if you pretend they're magic.

        Malmo has two files: `Schemas/MinecraftItems.txt` and `Schemas/MinecraftBlocks.txt`.
        You will note the item list is not exhaustive - it doesn't have dirt, and that can be in an inventory.
        So, look at items.json. That seems like an exhaustive list of inventory items.
        However, it has more entries than MinecraftItems.txt and MinecraftBlocks.txt combined. i.e., both are wrong.
        So, we use items.json for our items list. For our block list, we use the `Blocks` section of `Schemas/Types.xsd`
        Why do we use that? It has a reasonable length. I have no means to confirm its accuracy.
    """
    items_file = os.path.join(dir_path, 'data', 'items.txt')
    blocks_file = os.path.join(dir_path, 'data', 'blocks.txt')
    if not (os.path.isfile(items_file) and os.path.isfile(blocks_file)):
        raise FileNotFoundError("Could not find item and block data!")

    with open(items_file) as f:
        items = [line.strip() for line in f]
    with open(blocks_file) as f:
        blocks = [line.strip() for line in f]
    return items, blocks


ITEMS, BLOCKS = get_item_block_lists()
# Use these for observation spaces that interact with minecraft items and blocks.
#   Provides a non-meaningful but consistent ordering over the space of names.
# Currently no support for entities.


def key_observation(info, obs_space, key):
    """
    :param info: Info dict generated by Malmo mod. Must contain key.
    :param obs_space: unused.
    :param key: key to access in info dict.
    :return: info[key]
    """
    return info[key]


pov_observation = functools.partial(key_observation, key="pov")

compass_observation = functools.partial(key_observation, key="compassAngle")


def inventory_observation(info, obs_space):
    """
    For every item type in the observation space, add up how many of said item are in the inventory.
    Duplicates the MineRL default inventory observation.

    :param info: Info dict generated by Malmo mod.
    :param obs_space: The observation space. Used to decide which item information to include.
    :return: Dict of {item name : count in inventory}.
    """
    inventory_spaces = obs_space['inventory'].spaces

    inventory_dict = {k: 0 for k in inventory_spaces}
    # TODO change to maalmo
    if 'inventory' in info:
        for stack in info['inventory']:
            if 'type' in stack and 'quantity' in stack:
                type_name = stack['type']
                if type_name == 'log2':
                    type_name = 'log'

                try:
                    inventory_dict[type_name] += stack['quantity']
                except ValueError:
                    continue
                except KeyError:
                    # We only care to observe what was specified in the space.
                    continue
    else:
        print("Inventory information could not be found, returning empty inventory.")

    return inventory_dict
